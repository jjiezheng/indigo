#include "standard.h"

static const float KernelSize = 16;

uniform float2 HalfPixel;

uniform float Radius;
uniform float2 NoiseScale;
uniform float4 Kernel[16];

uniform float Far;
uniform float Near;

sampler2D NormalMap			 	: TEXUNIT0;
sampler2D DepthMap 		 		: TEXUNIT1;
sampler2D NoiseMap 		 		: TEXUNIT2;

uniform float4x4 Projection;
uniform float4x4 ProjInv;
uniform float4x4 ModelView;
uniform float4x4 View;
uniform float4x4 ViewProjInv;

struct VOutput {
      float4 position 		: POSITION;
      float2 texCoord		: TEXCOORD0;
};

VOutput vs(float4 position 	: POSITION,
		   float2 texCoord 	: TEXCOORD0) {
    VOutput OUT;
    OUT.position = position;
    OUT.texCoord = texCoord;
    return OUT;
}

struct POutput {
      float4 ssao 			: COLOR0;
      float4 temp			: COLOR1;
};

float ao(float3 normalWS, float3 positionWS, float depth, float2 texCoord, float2 sampleOffset) {
	float2 sampleCoord = texCoord + sampleOffset;
	float4 samplePositionClip = tex2NDC(sampleCoord, depth);
	float4 samplePositionWS = mul(ViewProjInv, samplePositionClip);
	samplePositionWS /= samplePositionWS.w;

	float3 diff = samplePositionWS.xyz - positionWS.xyz;
	float3 v = normalize(diff);
	float d = length(diff);

	float occlusion = max(0.0, dot(normalWS, v) * (1.0f / 1.0f + d));
	return occlusion;
}

float4 ps(float4 position 		: POSITION,
		  float2 texCoord 		: TEXCOORD0) : COLOR0 {

	float3 normalRaw = unpackNormal(NormalMap, texCoord);
	float3 normalWS = normalize(normalRaw);

	float3 random = tex2D(NoiseMap, texCoord * NoiseScale).rgb * 2.0f - 1.0f;

	float depth = unpackDepth(DepthMap, texCoord);
	float4 positionClip = tex2NDC(texCoord, depth);
	float4 positionWS = mul(ViewProjInv, positionClip);
	positionWS /= positionWS.w;

	float2 sampleOffsets[4] = { float2(1, 0), float2(-1, 0), float2(0, 1), float2(0, -1) };
	int kSamples = 4;
	float rad = Radius / positionWS.z;
	float occlusion = 0.0f;

	for (int i = 0; i < kSamples; i++) {
		float2 sampleOffsetRaw = sampleOffsets[i];
		float2 sampleOffset = reflect(sampleOffsetRaw, random.xy) * rad;

		float2 coord1 = sampleOffset;
  		float2 coord2 = float2(	coord1.x * 0.707 - coord1.y * 0.707,
			  					coord1.x * 0.707 + coord1.y * 0.707);

		occlusion += ao(normalWS, positionWS.xyz, depth, texCoord, coord1 * 0.25);
		occlusion += ao(normalWS, positionWS.xyz, depth, texCoord, coord2 * 0.5);
		occlusion += ao(normalWS, positionWS.xyz, depth, texCoord, coord1 * 0.75);
		occlusion += ao(normalWS, positionWS.xyz, depth, texCoord, coord2);
	}

	occlusion /= (float)kSamples * 4;

	return float4(occlusion, occlusion, occlusion, 1.0f);
}