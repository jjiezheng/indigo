#include "standard.h"

static const float KernelSize = 16;

uniform float2 HalfPixel;

uniform float Radius;
uniform float2 NoiseScale;
uniform float4 Kernel[16];

uniform float Far;
uniform float Near;

sampler2D NoiseMap : TEXUNIT0;
sampler2D NormalMap : TEXUNIT1;
sampler2D SSAODepthMap : TEXUNIT2;
sampler2D DepthMap : TEXUNIT3;

uniform float4x4 Projection;
uniform float4x4 ProjInv;
uniform float4x4 View;

struct VOutput {
      float4 position 		: POSITION;
      float2 texCoord		: TEXCOORD0;
};

VOutput vs(float4 position 	: POSITION,
		   float2 texCoord 	: TEXCOORD0) {
    VOutput OUT;
    OUT.position = position;
    OUT.texCoord = texCoord;
    return OUT;
}

float4 ps(float4 position 		: POSITION,
		  float2 texCoord 		: TEXCOORD0) : COLOR0 {

	float3 normalLocal = unpackNormal(NormalMap, texCoord);
	float3 normalViewSpace = mul(View, float4(normalLocal, 0.0f)).xyz;
	float3 normal = normalize(normalViewSpace);

	float depth = unpackDepth(DepthMap, texCoord);

	float4 positionNDC = tex2NDC(texCoord, depth);
	float4 positionViewRaw = mul(ProjInv, positionNDC);
	float4 positionView = positionViewRaw / positionViewRaw.w;

	float2 noiseTexCoords = texCoord * NoiseScale;
	float3 rvec = tex2D(NoiseMap, noiseTexCoords).rgb;
	
	float3 tangent = normalize(rvec - normal * dot(rvec, normal));
	float3 bitangent = cross(tangent, normal);
	float3x3 normalBasis = float3x3(tangent, bitangent, normal);

	float occlusionContribution = 0;

	int kSamples = 16;

	for (int i = 0; i < kSamples; i++) {
		float3 sample = Kernel[i].xyz * Radius;

		float3 sampleAtNormalBasis = mul(sample, normalBasis);
		float3 sampleAtViewPosition = positionView.xyz + sampleAtNormalBasis;

		float4 sampleClip = mul(Projection, float4(sampleAtViewPosition, 1));
		float4 sampleScreen = sampleClip / sampleClip.w;

		float2 sampleTexCoord = ndc2tex(sampleScreen.xy);

		float sampleDepth = unpackDepth(SSAODepthMap, sampleTexCoord);

		float occlusionFactor = 1.0f;

		if (sampleDepth * 0.5 + 0.5 < depth * 0.5 + 0.5) {
			//return float4(1, 0, 0, 1);
			occlusionFactor = 0.0f;
		}

		//return float4(sampleDepth, sampleDepth, sampleDepth, 1);

		//float sampleDepth = depthCompare(SSAODepthMap, sampleTexCoord, sampleScreen.z);

		//float rangeCheck = abs(sampleScreen.z - sampleDepth) < Radius ? 1.0 : 0.0; // probably going to need this?
		occlusionContribution += occlusionFactor;
	}

	float occlusion = (occlusionContribution / (float)kSamples);

	return float4(occlusion, occlusion, occlusion, 1.0f);
}