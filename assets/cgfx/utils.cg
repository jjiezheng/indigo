#ifndef UTILS_H
#define UTILS_H

float3 flipY(float3 vec) {
	return float3(vec.x, -vec.y, vec.z);
}

float3 expand(float3 vec) {
	return 2.0f * vec - 1.0f;
}

float3 contract(float3 vec) {
	float3 shifted = flipY(vec) + 1;
	return 0.5f * shifted;
}

float VSM_FILTER( float2 moments, float fragDepth ) 
{ 
   float lit = (float)0.0f;
   float E_x2 = moments.y; 
   float Ex_2 = moments.x * moments.x; 
   float variance = E_x2 - Ex_2;     
   float mD = moments.x - fragDepth; 
   float mD_2 = mD * mD; 
   float p = variance / (variance + mD_2); 
   lit = max( p, fragDepth <= moments.x ); 
           
   return lit;  //lit.x == VSM calculation 
} 

float ChebyshevUpperBound(float2 moments, float depth) {  
	float mean = moments.x;
	float meanSqr = moments.y;
	float Ex_2 = mean * mean; 
	float E_x2 = meanSqr;
	float shadowBias = 0.0f;
	float variance = min(max(E_x2 - Ex_2, 0.0f) + shadowBias, 1.0f);
	float m_d = (depth - mean);
	float p = variance / (variance + m_d * m_d);
	return max(p, depth <= mean);
}  

float shadow(sampler2D shadowMap, float2 shadowCoord, float depth) {
	float2 moments = tex2D(shadowMap, shadowCoord).xy;

	if (depth < moments.x) {
		return 1.0f;
	}

	return VSM_FILTER(moments, depth);
}

#endif
