#ifndef UTILS_H
#define UTILS_H

float3 flipY(float3 vec) {
	return float3(vec.x, -vec.y, vec.z);
}

float3 expand(float3 vec) {
	return 2.0f * (vec - 1.0f);
}

float3 contract(float3 vec) {
	return 0.5f * (flipY(vec) + float3(1.0f, 1.0f, 0.0f));
}

float linstep(float min, float max, float v)  
{  
  return clamp((v - min) / (max - min), 0, 1);  
}  

float ReduceLightBleeding(float p_max, float Amount)  
{  
  // Remove the [0, Amount] tail and linearly rescale (Amount, 1].  
   return linstep(Amount, 1, p_max);  
} 

float VSM_FILTER(float2 moments, float fragDepth) 
{ 
   float lit = (float)0.0f;
   float E_x2 = moments.y; 
   float Ex_2 = moments.x * moments.x; 
   float variance = E_x2 - Ex_2;     
   float mD = moments.x - fragDepth; 
   float mD_2 = mD * mD; 
   float p = variance / (variance + mD_2); 
   lit = max( p, fragDepth <= moments.x ); 
           
   return lit; 
} 

float ChebyshevUpperBound(float2 moments, float depth, float shadowBias) {  
	float mean = moments.x;
	float meanSqr = moments.y;
	float Ex_2 = mean * mean; 
	float E_x2 = meanSqr;
	float variance = min(max(E_x2 - Ex_2, 0.0f) + shadowBias, 1.0f);
	float m_d = (depth - mean);
	float p_max = variance / (variance + m_d * m_d);
  float p = depth <= mean;
  return max(p, p_max);	
}  

float ChebyshevUpperBound2(float2 Moments, float t)  
{  

	float g_MinVariance = 0.0f;
   float p = (t <= Moments.x);
   float Variance = Moments.y - (Moments.x * Moments.x);  
  Variance = max(Variance, g_MinVariance);  
  // Compute probabilistic upper bound.  
   float d = t - Moments.x;  
  float p_max = Variance / (Variance + d * d);  
  return max(p, p_max);  
}  

#endif
