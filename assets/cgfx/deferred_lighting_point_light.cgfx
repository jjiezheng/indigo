sampler2D NormalMap = sampler_state {
	MinFilter = Point;
	MagFilter = Point;
	WrapS = Clamp;
	WrapT = Clamp;
};

sampler2D DepthMap = sampler_state {
	MinFilter = Point;
	MagFilter = Point;
	WrapS = Clamp;
	WrapT = Clamp;
};

uniform float2 HalfPixel;
uniform float4 LightPosition;
uniform float3 LightColor;

uniform float4x4 WorldViewProj;
uniform float4x4 WorldView;
uniform float4x4 ViewProjInv;

struct VOutput {
      float4 position 			: POSITION;
      float4 screenPosition  	: TEXCOORD0;
};

VOutput vs(float4 position : POSITION) {
        VOutput OUT;
        OUT.position = mul(WorldViewProj, position);
        OUT.screenPosition = OUT.position;
        return OUT;
}

VOutput vsgl(float4 position : ATTR0) {
  return vs(position);
}

float4 ps(float4 screenPosition	: TEXCOORD0) : COLOR {
	// homoginize the screen position
	screenPosition.xy /= screenPosition.w;

	// convert screenPosition [-1,1] to texCoords [0,1]
	float2 texCoord = 0.5f * (float2(screenPosition.x, -screenPosition.y) + 1);

	// shift texCoords to center of screen pixel
	texCoord -= HalfPixel;

	// extract normal from Normal Map
	float3 normal = 2.0f * tex2D(NormalMap, texCoord).xyz - 1.0f;

	float depth = tex2D(DepthMap, texCoord);

	// setup the pixel position
	float4 position;
	position.xy = screenPosition.xy;
	position.z = depth;	
	position.w = 1.0f;	

	position = mul(position, ViewProjInv);
	position /= position.w;

	float3 finalColor;	

	// diffuse + ambient
	{
		float3 lightDirection = LightPosition - position;
		float diffuseStrength = max(0.0f, dot(normalize(normal), normalize(lightDirection)));
		finalColor = LightColor * diffuseStrength;
	}

	return float4(finalColor, 1);
}

technique dx {
  pass {
    VertexProgram = compile vs_4_0 vs();
    FragmentProgram = compile ps_4_0 ps();
  }
}

technique latest {
  pass {
    VertexProgram = compile glslv vsgl();
    FragmentProgram = compile glslf ps();
  }
}
