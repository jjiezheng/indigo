texture ColorMap  <
	string ResourceName = "";//Optional default file name
	string UIName =  "ColorMap Texture";
	string ResourceType = "2D";
>;

sampler2D ColorMapSampler = sampler_state {
	Texture = <ColorMap>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapS = Repeat;
	WrapT = Repeat;
};

texture NormalMap  <
	string ResourceName = "";//Optional default file name
	string UIName =  "NormalMap Texture";
	string ResourceType = "2D";
>;

sampler2D NormalMapSampler = sampler_state {
	Texture = <NormalMap>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapS = Repeat;
	WrapT = Repeat;
};

float3 Ambient : Ambient <
    string UIName =  "Ambient Light";
    string UIWidget = "Color";
> = {0.0f,1.0f,1.0f};

float3 LightPosition : Position <
    string Object = "PointLight0";
    string UIName =  "LightPosition";
    string Space = "World";
> = {-0.5f,2.0f,1.25f};

float4x4 WorldViewProj : WorldViewProjection;
float4x4 World : World;
float4x4 WorldLight : Projection;

struct VOutput {
	float4 position       	: POSITION;
	float3 normal         	: TEXCOORD0;
  	float3 vPosition      	: TEXCOORD1;
  	float2 texCoord			: TEXCOORD2;
  	float4 shmapCoord 		: TEXCOORD3;
};

VOutput mainVS(	float4 position : POSITION,
              	float3 normal 	: NORMAL,
				float2 texCoord : ATTR8) { // opengl doesnt seem to support TEXCOORD0

	VOutput OUT;
	
    float4 modelPosition = mul(World, position); 
    OUT.vPosition = modelPosition.xyz / modelPosition.z;
    OUT.normal = normal;
	OUT.texCoord = texCoord;
    OUT.shmapCoord = mul(WorldLight, position);
	OUT.position = mul(WorldViewProj, position);
	
	return OUT;
}

float4 mainPS(	float3 normal     		: TEXCOORD0,
				float3 vPosition  		: TEXCOORD1,
            	float2 texCoord   		: TEXCOORD2,
				float2 shadowCoord   	: TEXCOORD3) : COLOR {

  float4 finalColor = float4(0, 0, 0, 1);

  float4 bumpColor = tex2D(NormalMapSampler, texCoord);
  float4 diffuseColor = tex2D(ColorMapSampler, texCoord);

  // diffuse + ambient
  {
    float3 lightDirection = LightPosition - vPosition;
    float diffuseStrength = max(0.0f, dot(normalize(bumpColor.rgb), normalize(lightDirection.xyz)));

    float4 diffuseAmount = diffuseColor * diffuseStrength;
    finalColor.rgb += diffuseAmount.rgb + Ambient;
  }
  
  return diffuseColor;
}

technique technique0 {
	pass p0 {
		CullFaceEnable = false;	
		VertexProgram = compile arbvp1 mainVS();
		FragmentProgram = compile arbfp1 mainPS();
	}
}